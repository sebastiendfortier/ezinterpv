!!!mod VerticalGrid_class - Class that represents one vertical grid
!module VerticalGrid_class
!module VerticalGrid_class8
use VerticalInterpolationConstants
!
!AUTHOR
!     J.W. Blezius MAY 2002 helper on top of the Interp1D library
!
!REVISION
! v1_0    Blezius J.W.          - initial version
! v1_4    Blezius J.W. AUG 2009 - split this file off of VerticalGrid.cdk90
!    ?    Blezius J.W. FEB 2010 - support UNnormalized hybrid grid
!                               - (due to hyb_to_pres) no longer require hybrid
!                                 ceiling to be the first element
!                               - inform the user only once of converting to ln P
!         Blezius J.W. DEC 2010 - add support for the staggered grid type
!
!OBJECT
!        A vertical grid is defined by the specific set of vertical levels in the
!        grid, along with an indication of the representation that is used for
!        the vertical levels, as well as all the parameters, except for surface
!        pressure, that are necessary to convert from that representation to a
!        representation by pressure.
!
!        Naturally, there is a constructor to define the grid and a destructor to
!        release memory that is associated with the grid.  Together, these are
!        the VerticalGrid_class that is defined in this module.
!       
!
!NOTES
!        Throughout, the object of the class on which the functions are to
!        operate is passed to each function as its first argument.
!
!        Ideally, the class member that defines what kind of vertical
!        representation is used would not be necessary.  Instead, each kind of
!        representation would be contained in a different sub-class of the
!        VerticalGrid_class.  Because fortran 90 does not explicitly support
!        inheritance, the older methods used here are easier.
!
!        The constructor and destructor do not deallocate the class object itself
!        because it is not necessarily on the heap.
!
!!
!!$  use vGrid_Descriptors, only: vgrid_descriptor, VGD_OK, &
!!$                               vgd_new, vgd_get, vgd_levels
  use vGrid_Descriptors
  implicit none
  public
  save

  real(real48), parameter :: r_MBAR_PER_PASCAL = real(0.01d0,real48)

  type T_VerticalGrid
    ! information capable of specifying particular grid types is placed in
    !  variables here:
    integer N_gridType                  ! representation used for vertical levels
    integer N_numVLevels                ! number of vertical points in this grid

                                        ! vertical levels defined for this grid,
                                        ! in units that are implied by gridType
                                        ! (IP1 values, decoded from FSTD format)
    real(real48), pointer, dimension(:) :: R_vLevel_p
                                        ! The ip1's of the field levels that are
                                        ! present in the associated field
    integer, pointer, dimension(:) :: N_ip1_p
                                        ! The vgd that describes this grid
    type(vgrid_descriptor), pointer::O_vGridDesc_p
    integer:: N_fileUnit                ! File unit associated with O_vGridDesc_p

    ! Other parameters that may be necessary, depending on gridType
    ! (surface pressure is not explicitly a part of the vertical grid)

    ! hybrid parameters
    real :: R_pTopAvg                   ! pressure (mb) at the model top(ceiling)
    real :: R_pRef                      ! reference pressure (mb)
    real :: R_rCoef                     ! known as 'expansion co-efficient'
    real :: R_rCoef_2                   ! for staggered co-ordinates
    integer :: n_vcode                  ! vgrid's definition of the grid type
  end type T_VerticalGrid

  type T_VerticalGridPtr
    type(T_VerticalGrid), pointer :: Ptr
  end type T_VerticalGridPtr

  interface assignment(=)
    module procedure M_AssignVerticalGrid
  end interface

  interface operator(/=)
    module procedure M_NotEqualVerticalGrid
    module procedure M_NotEqualVerticalGridPtr
  end interface



contains

!!!func M_NotEqualVerticalGridPtr - non-equality comparison operator
  logical function M_NotEqualVerticalGridPtr(o_gridAPtr, o_gridBPtr)
!
!AUTHOR
!     J.W. Blezius OCT 2002
!
!REVISION
! v1_0    Blezius J.W.          - initial version
!
!OBJECT
!        To compare (that means a deep comparison) the value of one vertical
!        grid object to another.
!
!ARGUMENTS
    type (T_VerticalGridPtr), intent(in) :: o_gridAPtr, &
                                            o_gridBPtr
!
!NOTES
!
!!

  real, parameter :: r_ZERO = 1.0e-8
  integer :: k                          ! index of the vertical levels

  type (T_VerticalGrid), pointer :: o_gridA_p, &
                                    o_gridB_p

  o_gridA_p => o_gridAPtr%Ptr
  o_gridB_p => o_gridBPtr%Ptr


  M_NotEqualVerticalGridPtr = .false.   ! assume equal until proven otherwise

  if(     o_gridA_p%N_gridType   /= o_gridB_p%N_gridType &
     .or. o_gridA_p%N_numVLevels /= o_gridB_p%N_numVLevels &
     .or. o_gridA_p%N_fileUnit   /= o_gridB_p%N_fileUnit &
    ) then
    M_NotEqualVerticalGridPtr = .true.
  else if((     o_gridA_p%N_gridType == N_GRID_TYPE_HYBRID &
           .or. o_gridA_p%N_gridType == N_GRID_TYPE_HYBRID_NOTNORM &
           .or. o_gridA_p%N_gridType == N_GRID_TYPE_STAGGERED &
          )  .and.(     r_ZERO < abs(o_gridA_p%R_pTopAvg - o_gridB_p%R_pTopAvg) &
                   .or. r_ZERO < abs(o_gridA_p%R_pRef    - o_gridB_p%R_pRef) &
                   .or. r_ZERO < abs(o_gridA_p%R_rCoef   - o_gridB_p%R_rCoef) &
                   .or. r_ZERO < abs(o_gridA_p%R_rCoef_2 - o_gridB_p%R_rCoef_2) &
                   .or. o_gridA_p%n_vcode    /= o_gridB_p%n_vcode &
                  ) &
         ) then
      M_NotEqualVerticalGridPtr = .true.
  else if((o_gridA_p%N_gridType == N_GRID_TYPE_STAG5005 &
          )  .and.(     r_ZERO < abs(o_gridA_p%R_pRef    - o_gridB_p%R_pRef) &
                   .or. r_ZERO < abs(o_gridA_p%R_rCoef   - o_gridB_p%R_rCoef) &
                   .or. r_ZERO < abs(o_gridA_p%R_rCoef_2 - o_gridB_p%R_rCoef_2) &
                   .or. o_gridA_p%n_vcode    /= o_gridB_p%n_vcode &
                  ) &
         ) then
      M_NotEqualVerticalGridPtr = .true.
  else if(.not. (o_gridA_p%O_vGridDesc_p == o_gridB_p%O_vGridDesc_p)) then
      M_NotEqualVerticalGridPtr = .true.
  else
    do k=1, o_gridA_p%N_numVLevels
      if(r_ZERO < abs(o_gridA_p%R_vLevel_p(k) - o_gridB_p%R_vLevel_p(k)) &
         .or. o_gridA_p%N_ip1_p(k) /= o_gridB_p%N_ip1_p(k) &
        ) then
        M_NotEqualVerticalGridPtr = .true.
        exit                            ! no need to check any further
      end if
    end do
  end if

  end function M_NotEqualVerticalGridPtr


!!!func M_NotEqualVerticalGrid - non-equality comparison operator
  logical function M_NotEqualVerticalGrid(o_gridA, o_gridB)
!
!AUTHOR
!     J.W. Blezius SEPT 2002
!
!REVISION
! v1_0    Blezius J.W.          - initial version
!
!OBJECT
!        To compare (that means a deep comparison) the value of one vertical
!        grid object to another.
!
!ARGUMENTS
    type (T_VerticalGrid), target, intent(in) :: o_gridA, &
                                                 o_gridB
!
!NOTES
!
!!
    type (T_VerticalGridPtr) :: o_gridAPtr, &
                                o_gridBPtr

    o_gridAPtr%Ptr => o_gridA
    o_gridBPtr%Ptr => o_gridB

    M_NotEqualVerticalGrid = (o_gridAPtr /= o_gridBPtr)

  end function M_NotEqualVerticalGrid



!!!s/r M_AssignVerticalGrid - assigment operator
  subroutine M_AssignVerticalGrid(o_gridOut, o_gridIn)
!
!AUTHOR
!     J.W. Blezius SEPT 2002
!
!REVISION
! v1_0    Blezius J.W.          - initial version
!
!OBJECT
!        To assign (that means a deep copy) the value of one vertical grid
!        object to another.
!
!ARGUMENTS
    type (T_VerticalGrid), intent(out) :: o_gridOut
    type (T_VerticalGrid), intent(in)  :: o_gridIn
!
!NOTES
!        This assumes that the destination vLevel array has been allocated, and
!        that the two vLevels have the same dimensions.
!
!!
    external flush
    integer :: n_error

    o_gridOut%N_gridType   = o_gridIn%N_gridType
    o_gridOut%N_numVLevels = o_gridIn%N_numVLevels
                                                      ! deep copy
    if(.not. associated(o_gridOut%R_vLevel_p)) then
        allocate(o_gridOut%R_vLevel_p(o_gridIn%N_numVLevels), STAT=n_error)
        if(n_error /= 0) then
          write(6, *)'Error allocating vLevel in M_AssignVerticalGrid:  error=',&
                     n_error
          call flush(6)
          return
        endif
    end if

    if(associated(o_gridIn%N_ip1_p))then
      if(.not. associated(o_gridOut%N_ip1_p)) then
          allocate(o_gridOut%N_ip1_p(o_gridIn%N_numVLevels), STAT=n_error)
          if(n_error /= 0) then
            write(6, *)'Error allocating ip1 in M_AssignVerticalGrid:  error=',&
                       n_error
            call flush(6)
            return
          endif
      end if
    else
      if(associated(o_gridOut%N_ip1_p)) then
        deallocate(o_gridOut%N_ip1_p)
      end if
    end if

    o_gridOut%R_vLevel_p      = o_gridIn%R_vLevel_p
    if(associated(o_gridIn%N_ip1_p))then
      o_gridOut%N_ip1_p         = o_gridIn%N_ip1_p
    end if
    o_gridOut%O_vGridDesc_p  => o_gridIn%O_vGridDesc_p
    o_gridOut%N_fileUnit      = o_gridIn%N_fileUnit
    o_gridOut%R_pTopAvg       = o_gridIn%R_pTopAvg
    o_gridOut%R_pRef          = o_gridIn%R_pRef
    o_gridOut%R_rCoef         = o_gridIn%R_rCoef
    o_gridOut%R_rCoef_2       = o_gridIn%R_rCoef_2
    o_gridOut%n_vcode    = o_gridIn%n_vcode
  end subroutine M_AssignVerticalGrid



!!!func N_ConstructNull - constructor:  Put the object in a valid state
  integer function N_ConstructNull(that, n_numVLevelsIn)
                                        ! returns error indication:  0='no error'
!
!AUTHOR
!     J.W. Blezius DEC 2003
!
!REVISION
! v1_3    Blezius J.W. DEC 2003 - initial version
!
!OBJECT
!        The null VerticalGrid constructor.  This constructor simply puts the
!        object in a valid state, but containing no data.  In particular, the
!        pointer, R_vLevel_p, contained by the object is made to actually point
!        to some memory.
!
!ARGUMENTS
    type(T_VerticalGridPtr), intent(inout) :: that
    integer, intent(in)::n_numVLevelsIn ! number of vertical levels in the object
!
!NOTES
!        The array to which R_vLevel_p points will be the right size only if the
!        user uses a consistent number of vertical levels.
!
!!
    external flush
    integer :: n_error
    type(T_VerticalGrid), pointer :: this

    this => that%Ptr
    N_ConstructNull = 0                 ! no error yet
    nullify(this%O_vGridDesc_p)

    if(n_numVLevelsIn == 0) then
        ! The size is not known yet; just nullify the pointers
        nullify(this%R_vLevel_p)
        nullify(this%N_ip1_p)
    else
        ! Allocate the array of vertical levels
        allocate(this%R_vLevel_p(n_numVLevelsIn), STAT=n_error)
        if(n_error /= 0) then
          write(6, *) 'Error allocating vLevel in N_ConstructNull:  error=', &
                      n_error
          call flush(6)
          N_ConstructNull = N_VI_VIERR_FAILED_ALLOCATION
          return
        endif ! n_error /= 0
        this%R_vLevel_p = 0.

        allocate(this%N_ip1_p(n_numVLevelsIn), STAT=n_error)
        if(n_error /= 0) then
          write(6, *) 'Error allocating vLevel in N_ConstructNull:  error=', &
                      n_error
          call flush(6)
          N_ConstructNull = N_VI_VIERR_FAILED_ALLOCATION
          return
        endif ! n_error /= 0
        this%N_ip1_p = 0

    end if ! n_numVLevelsIn == 0
    
    ! Array of vertical levels was successfully allocated.
    this%N_numVLevels = n_numVLevelsIn
    ! Initialize all other values to zero
    this%N_gridType = 0
    this%N_fileUnit = 0
    this%R_pTopAvg = 0.
    this%R_pRef = 0.
    this%R_rCoef = 0.
    this%R_rCoef_2 = 0.
    this%n_vcode = 0

end function N_ConstructNull



!!!func N_Viqkdef - constructor:  Quick definition of the grid for vertical
!                                 integration
  integer function N_Viqkdef(that, n_numVLevelsIn, n_gridTypeIn, r_vLevelIn, &
                             r_pTopAvgIn, r_pRefIn, r_rCoefIn, r_rCoef_2In, &
                             n_kind_vgridIn, n_version_vgridIn, &
                             n_ip1In, o_vGridDescIn_p)
                                        ! returns error indication:  0='no error'
!
!AUTHOR
!     J.W. Blezius MAY 2002 helper on top of the Interp1D library
!
!REVISION
! v1_0    Blezius J.W.          - initial version
!
!OBJECT
!        The VerticalGrid constructor.  The attributes of the VerticalGrid_class
!        are initialized.
!
!ARGUMENTS
    type(T_VerticalGridPtr), intent(inout) :: that
    integer, intent(in)::n_numVLevelsIn ! number of vertical levels in r_vLevelIn
    integer, intent(in) :: n_gridTypeIn ! the type of grid -- see values above

                                        ! the levels, see n_gridTypeIn for units
    real(real48), dimension(n_numVLevelsIn), intent(in) :: r_vLevelIn

    ! These three arguments are optional as a group (for N_GRID_TYPE_HYBRID)
                                        ! average pressure (mb) at model top
    real, optional,intent(in)::r_pTopAvgIn
    real, optional,intent(in)::r_pRefIn ! reference pressure (mb)
    real, optional,intent(in)::r_rCoefIn! known as 'expansion co-efficient'
                                        ! for staggered co-ordinates
    real, optional, intent(in) :: r_rCoef_2In
                                        ! vgrid's definition of the grid type
    integer, optional, intent(in) :: n_kind_vgridIn
    integer, optional, intent(in) :: n_version_vgridIn
                                        ! The ip1's of field levels present
    integer, optional, dimension(n_numVLevelsIn), intent(in) :: n_ip1In
                                        ! The vgd that describes this grid
    type(vgrid_descriptor), optional, pointer, intent(in)::o_vGridDescIn_p
!
!!
    external flush
    integer :: n_error, n_kind, n_version
    type(T_VerticalGrid), pointer :: this
    integer, dimension(:), pointer :: n_ip1_p
    real(8) :: ptop_out_dummy

    this => that%Ptr
    N_Viqkdef = 0                       ! no error yet

    nullify(n_ip1_p)

    ! Allocate the array of vertical levels
    allocate(this%R_vLevel_p(n_numVLevelsIn), STAT=n_error)
    if(n_error /= 0) then
      write(6, *) 'Error allocating vLevel in N_Viqkdef:  error=', n_error
      call flush(6)
      N_Viqkdef = N_VI_VIERR_FAILED_ALLOCATION
      return
    endif

    allocate(this%N_ip1_p(n_numVLevelsIn), STAT=n_error)
    if(n_error /= 0) then
      write(6, *) 'Error allocating vLevel in N_Viqkdef:  error=', n_error
      call flush(6)
      N_Viqkdef = N_VI_VIERR_FAILED_ALLOCATION
      return
    endif
    this%N_ip1_p = 0
    
    ! Array of vertical levels was successfully allocated.
    ! Assign these and other values
    this%R_vLevel_p = r_vLevelIn
    this%N_gridType = n_gridTypeIn
    this%N_numVLevels = n_numVLevelsIn

    if(n_gridTypeIn == N_GRID_TYPE_STAG5005) then
      this%R_pTopAvg = 0.
    else if(present(r_pTopAvgIn))then
      this%R_pTopAvg = r_pTopAvgIn
    else
      this%R_pTopAvg = 0.
    end if

    if(present(r_pRefIn))then
      this%R_pRef = r_pRefIn
    else
      this%R_pRef = 0.
    end if

    if(present(r_rCoefIn))then
      this%R_rCoef = r_rCoefIn
    else
      this%R_rCoef = 0.
    end if

    if(present(r_rCoef_2In))then
      this%R_rCoef_2 = r_rCoef_2In
    else
      this%R_rCoef_2 = 0.
    end if

    if(present(n_ip1In))then
      this%N_ip1_p = n_ip1In
    else
      this%N_ip1_p = 0
    end if

    if(present(n_kind_vgridIn) .and. present(n_version_vgridIn)) then
      this%n_vcode = n_kind_vgridIn * 1000 + n_version_vgridIn

    else
      select case (n_gridTypeIn)
      case (N_GRID_TYPE_SIGMA)
        this%n_vcode = 1001

      case (N_GRID_TYPE_ETA)
        this%n_vcode = 1002

      case (N_GRID_TYPE_HYBRID)
        this%n_vcode = 1003

      case (N_GRID_TYPE_PRESSURE)
        this%n_vcode = 2001

      case (N_GRID_TYPE_HYBRID_NOTNORM)
        this%n_vcode = 5001

      case (N_GRID_TYPE_STAGGERED)
        this%n_vcode = 5002

      case (N_GRID_TYPE_STAG5005)
        this%n_vcode = 5005

      case (N_GRID_TYPE_GENERIC)
        this%n_vcode = N_GRID_TYPE_GENERIC

      case default
        this%n_vcode = 0
      end select
    end if

!    if(     n_gridTypeIn == N_GRID_TYPE_HYBRID &
!       .or. n_gridTypeIn == N_GRID_TYPE_HYBRID_NOTNORM &
!       .or. n_gridTypeIn == N_GRID_TYPE_STAGGERED &
!       .or. n_gridTypeIn == N_GRID_TYPE_STAG5005) then
    if(.true.) then

      if(present(o_vGridDescIn_p)) then
        this%O_vGridDesc_p => o_vGridDescIn_p
      else
        allocate(this%O_vGridDesc_p)

        ! Create O_vGridDesc_p right now
        ! (Although the vgrid documentation doesn't say it, vgd_new accepts only
        !  momentum levels as input.  The relationship to thermodynamic levels
        !  being defined mathematically, this is sufficient to determine also
        !  the thermodynamic levels.):
        n_kind    = this%n_vcode / 1000
        n_version = this%n_vcode - (n_kind * 1000)
        select case(this%n_vcode)

        case (1001)
          n_error = vgd_new(this%O_vGridDesc_p, n_kind, n_version, &
                            real(this%R_vLevel_p))

        case (1002)
          n_error = vgd_new(this%O_vGridDesc_p, n_kind, n_version, &
                            real(this%R_vLevel_p),&
                            ptop_8=real(this%R_pTopAvg/r_MBAR_PER_PASCAL, kind=8))

        case (1003)
          n_error = vgd_new(this%O_vGridDesc_p, n_kind, n_version, &
                            real(this%R_vLevel_p), this%R_rCoef, &
                            ptop_8=real(this%R_pTopAvg/r_MBAR_PER_PASCAL, kind=8),&
                            pref_8=real(this%R_pRef/r_MBAR_PER_PASCAL, kind=8))

        case (2001)
          n_error = vgd_new(this%O_vGridDesc_p, n_kind, n_version, &
                            real(this%R_vLevel_p))

        case (5001)
          n_error = vgd_new(this%O_vGridDesc_p, n_kind, n_version, &
                            real(this%R_vLevel_p), this%R_rCoef, &
                            ptop_8=real(this%R_pTopAvg/r_MBAR_PER_PASCAL, kind=8),&
                            pref_8=real(this%R_pRef/r_MBAR_PER_PASCAL, kind=8))

        case (5002)
          n_error = vgd_new(this%O_vGridDesc_p, n_kind, n_version, &
                            real(this%R_vLevel_p), this%R_rCoef, this%R_rCoef_2,&
                            real(this%R_pTopAvg/r_MBAR_PER_PASCAL, kind=8), &
                            real(this%R_pRef/r_MBAR_PER_PASCAL, kind=8))

        case (5005)
          n_error = vgd_new(this%O_vGridDesc_p, n_kind, n_version, &
                            real(this%R_vLevel_p), this%R_rCoef, this%R_rCoef_2,&
                            pref_8=real(this%R_pRef/r_MBAR_PER_PASCAL, kind=8), &
                            ptop_out_8=ptop_out_dummy, &
                            dhm=10.0, dht=1.5)

        case (N_GRID_TYPE_GENERIC)
          ! These cases are not supported by the vertical-grid descriptor
          deallocate(this%O_vGridDesc_p)
          nullify(this%O_vGridDesc_p)

          ! N_ip1_p is used only in association with O_vGridDesc_p
          deallocate(this%N_ip1_p)
          nullify(this%N_ip1_p)
          n_error = 0

        case default
          n_error = 0

        end select

        ! Test the return value from vgd_new
        if(n_error /= 0) then
          write(6,*)'Error from vgd_new in N_Viqkdef:  error=', n_error
          write(6,*)'Ezinterpv exiting.'
          call flush(6)
          call exit(2)
        endif

        if(associated(this%O_vGridDesc_p)) then
          ! In order to be useful, this%O_vGridDesc_p will require this%N_ip1_p
          ! (Ask for VIPM, because vgd_new assumed the r_vLevelIn to be VIPM.)
          n_error = vgd_get(this%O_vGridDesc_p, 'VIPM', n_ip1_p)
          if(n_error .ne. VGD_OK)then
            write(6,*)'ERROR in VerticalGrid_class%N_VertiGridGetP, from vgd_get:', n_error
          end if
          ! vgd might have (depending on the grid type) added hyb=1 (the last
          ! entry) and the 10m level (after hyb=1) to the list.  Remove them.
          this%N_ip1_p(:) = n_ip1_p(:size(this%N_ip1_p))
          deallocate(n_ip1_p) ! vgd_get allocated it
        end if ! associated

      end if

!   else if(n_gridTypeIn == N_GRID_TYPE_ETA) then
!     ! One parameter must be supplied LATER (in ConvertToLnP)
!     this%R_pTopAvg = 0.
!     this%R_pRef = 0.
!     this%R_rCoef = 0.
    else
      ! Set the hybrid parameters to 0
      this%R_pTopAvg = 0.
      this%R_pRef = 0.
      this%R_rCoef = 0.
      this%R_rCoef_2 = 0.
    endif

  end function N_Viqkdef



!!!func L_ValueIncreasesWithHeight - Indicate whether the vLevel values increase
!                                    with height
  logical function L_ValueIncreasesWithHeight(n_gridTypeIn)
!
!AUTHOR
!     J.W. Blezius SEPTEMBER 2002 helper on top of the Interp1D library
!
!REVISION
! v1_0    Blezius J.W.          - initial version
!
!OBJECT
!        For the purposes of ordering the vertical levels, it is necessary to
!        know which way is up.  This function gives that information.
!
!ARGUMENTS
    integer :: n_gridTypeIn
!
!NOTES
!        While it would be cleaner if the argument were a pointer to the
!        particular vertical grid in question, this is inconvenient because the
!        routine that calls this function holds the vertical grid as an element
!        of another user-defined type.  Unfortunately, fortran90 doesn't allow a
!        component of a user-defined type to be the object of a pointer.
!
!!
    L_ValueIncreasesWithHeight = (n_gridTypeIn == N_GRID_TYPE_GENERIC)
  end function L_ValueIncreasesWithHeight



!!!func N_VertGridGetP - Create 'cube' of vertical levels in units of P (mb)
  integer function N_VertGridGetP(that, r_P, n_ni, n_nj, r_pSurf, r_pTop)
                                        ! returns error indication:  0='no error'
!
!AUTHOR
!     J.W. Blezius JULY 2002 helper on top of the Interp1D library
!
!REVISION
! v1_0    Blezius J.W.          - initial version
!
!OBJECT
!        The vertical grid is a 1-D object.  The product is taken with the
!        horizontal surface pressure, r_pSurf, to produce a cube of vertical
!        levels, in pressure units.
!
!        The exception is the 'generic' grid type.  In this case, the vertical
!        levels are simply multiplied horizontally, and no attempt is made to
!        obtain a pressure.
!
!NOTES
!
!ARGUMENTS

                                        ! parameter cannot be a pointer to a
                                        ! user type:  replace 'this' with 'that'
    type(T_VerticalGridPtr), intent(inout) :: that

    integer, intent(in) :: n_ni, n_nj   ! horizontal dimensions

                                        ! vertical levels as pressure
                                        ! (These dimensions must be explicit
                                        !  because r_P is used to call
                                        !  hyb_to_pres which has a fortran77
                                        !  interface.)
    real(real48), dimension(n_ni,n_nj,that%Ptr%N_numVLevels), intent(out) :: r_P

                                        ! surface pressure for each horiz point,
                                        ! in units of mb
    real(real48), dimension(:,:), intent(in) :: r_pSurf

                                        ! ceiling pressure for each horiz point
                                        ! required only for eta units,
                                        ! in units of mb
    real(real48), dimension(:,:), optional, intent(in) :: r_pTop
!
!!
    external flush
    integer, external :: hyb_to_pres

    integer i, j                        ! indices of the horizontal locations
    integer k                           ! index of the vertical levels
! integer ikind                       ! kind of grid (convip's kind, extended)
    integer :: n_error
    type(T_VerticalGrid), pointer :: this

    real(real48), dimension(:,:,:), pointer :: r_P_p
! real(single), dimension(n_ni,n_nj,that%Ptr%N_numVLevels) :: r_P_single
    logical, parameter :: l_IN_LOG = .false.


    this => that%Ptr
    nullify(r_P_p)
    N_VertGridGetP = 0                  ! no error yet

    !
    ! Create the 'cube' of source vertical levels
    !
    select case (this%N_gridType)
!   case(N_GRID_TYPE_SIGMA, N_GRID_TYPE_ETA, N_GRID_TYPE_HYBRID, &
!        N_GRID_TYPE_PRESSURE, N_GRID_TYPE_HYBRID_NOTNORM, &
!        N_GRID_TYPE_STAGGERED, N_GRID_TYPE_STAG5005)
    case default
                                        ! Obtain, the cube of P.
                                        ! vgd_levels allocates r_P_p
      n_error = vgd_levels(this%O_vGridDesc_p, this%N_ip1_p(:this%N_numVLevels),&
                           r_P_p, r_pSurf / r_MBAR_PER_PASCAL, l_IN_LOG)
      if(n_error .ne. VGD_OK)then
        write(6,*)'ERROR in VerticalGrid_class%N_VertGridGetP, ', &
                  'from vgd_levels:', n_error
      end if
      r_P = r_P_p * r_MBAR_PER_PASCAL

      deallocate(r_P_p)

    case(N_GRID_TYPE_GENERIC)
      do k=1,this%N_numVLevels
        ! N_GRID_TYPE_GENERIC:  don't try to convert the vertical levels
        r_P(:,:,k) = this%R_vLevel_p(k)
      end do

!    case(N_GRID_TYPE_HYBRID) ! not supported by vgrid - could do it like this:
!      ikind = 1
!
!      if(0 /= hyb_to_pres(r_P_single, real(this%R_vLevel_p), this%R_pTopAvg, &
!                          this%R_rCoef, this%R_pRef, ikind, &
!                          real(r_pSurf, kind=4), n_ni, n_nj, &
!                          this%N_numVLevels) &
!                         ) then
!        write(6,*)'In N_VertGridGetP:  hyb_to_pres FAILED'
!        call flush(6)
!        N_VertGridGetP = N_VI_VGERR_HYBRID_TO_PRES_CONVN
!      end if
!      r_P = r_P_single

!    case(N_GRID_TYPE_ETA) ! vgrid gives a different result from this:
!      if(.not. present(r_pTop)) then
!        write(6,*)'ERROR in N_VertGridGetP:  pTop required for eta units'
!        call flush(6)
!        N_VertGridGetP = N_VI_VGERR_PTOP_MISSING
!      else
!        do k=1,this%N_numVLevels
!          do j=1,n_nj
!            do i=1,n_ni
!              r_P(i,j,k) =   r_pTop(i,j) &
!                           + (r_pSurf(i,j) - r_pTop(i,j)) * this%R_vLevel_p(k)
!            end do
!          end do
!        end do
!      end if
      end select

  end function N_VertGridGetP



!!!func N_VertGridGetLnP - Create 'cube' of vertical levels in units of ln P
  integer function N_VertGridGetLnP(that, r_lnP, n_ni, n_nj, r_pSurf, r_pTop)
                                        ! returns error indication:  0='no error'
!
!AUTHOR
!     J.W. Blezius JULY 2002 helper on top of the Interp1D library
!
!REVISION
! v1_0    Blezius J.W.          - initial version
!
!OBJECT
!        Converts each pressure in the cube of vertical levels to ln P.
!
!        The exception is the 'generic' grid type.  In this case, the 'pressure'
!        is copied directly as 'ln P', and no conversion is performed.
!
!NOTES
!        The conversion from P to ln P cannot be left up to the user and must be
!        performed here because there is one case (generic) where the conversion
!        has no sense.  This routine automatically does no conversion in this
!        case.
!
!ARGUMENTS

                                        ! parameter cannot be a pointer to a
                                        ! user type:  replace 'this' with 'that'
    type(T_VerticalGridPtr), intent(inout) :: that

    integer, intent(in) :: n_ni, n_nj   ! horizontal dimensions

                                        ! ln pressure, referenced to 1 mb
    real(real48), dimension(:,:,:), intent(out) :: r_lnP

                                        ! surface pressure for each horiz point,
                                        ! in units of mb
    real(real48), dimension(:,:), intent(in) :: r_pSurf

                                        ! ceiling pressure for each horiz point
                                        ! required only for eta units,
                                        ! in units of mb
    real(real48), dimension(:,:), optional, intent(in) :: r_pTop
!
!!
    type(T_VerticalGrid), pointer :: this
    logical :: l_firstTime=.true.


    this => that%Ptr
    

    if(this%N_gridType /= N_GRID_TYPE_GENERIC .and. l_firstTime .eqv. .true.) then
         l_firstTime=.false.
         write(6,*)' '
         write(6,*)'In ez_interpv, converting the vertical levels to ln P (1 mb ref level) before interpolating.'
         write(6,*)'(This message will not be repeated.)'
         write(6,*)' '
    endif

                                        ! Obtain the cube of pressures
                                        ! After this call, lnP is really just P
    N_VertGridGetLnP = N_VertGridGetP(that, r_lnP, n_ni, n_nj, r_pSurf, r_pTop)

    select case (this%N_gridType)
    case(N_GRID_TYPE_SIGMA, N_GRID_TYPE_PRESSURE, N_GRID_TYPE_HYBRID, &
         N_GRID_TYPE_ETA, N_GRID_TYPE_HYBRID_NOTNORM, N_GRID_TYPE_STAGGERED, &
         N_GRID_TYPE_STAG5005)
                                        ! Convert the 'cube' of source vertical
                                        ! levels from P to ln P
      r_lnP = log(r_lnP)

    case(N_GRID_TYPE_GENERIC)
      ! Do nothing

    case default
      ! If execution leads here, it is because a new gridType has been added.
      write(6,*)'WARNING:  in N_VertGridGetLnP, grid type not recognized.'
      write(6,*)'          Copying P directly to ln P.'
      ! Do nothing
    end select

  end function N_VertGridGetLnP



!!!s/r M_ReleaseVerticalGrid - VerticalGrid destructor
  subroutine M_ReleaseVerticalGrid(that)
!
!AUTHOR
!     J.W. Blezius MAY 2002 helper on top of the Interp1D library
!
!REVISION
! v1_0    Blezius J.W.          - initial version
!
!OBJECT
!        The memory associated with the attributes is released.
!
!ARGUMENTS
    implicit none
    type(T_VerticalGridPtr), intent(inout) :: that
!
!!
    external flush
    integer :: n_error

    ! Release the memory associated with the array of vertical levels.
    if( associated(that%Ptr%R_vLevel_p) ) then
      deallocate (that%Ptr%R_vLevel_p, STAT=n_error)
      if(n_error /= 0) then
        write(6, *)'Error deallocating vLevel in M_ReleaseVerticalGrid:  ', &
                   'error=', n_error
        call flush(6)
      end if
    end if

    if( associated(that%Ptr%N_ip1_p) ) then
      deallocate (that%Ptr%N_ip1_p, STAT=n_error)
      if(n_error /= 0) then
        write(6, *)'Error deallocating vLevel in M_ReleaseVerticalGrid:  ', &
                   'error=', n_error
        call flush(6)
      end if
    end if

  end subroutine M_ReleaseVerticalGrid

!end module VerticalGrid_class
!end module VerticalGrid_class8
