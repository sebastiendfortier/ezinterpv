!!!mod VerticalGrid_class - Class that represents one vertical grid
!module VerticalGrid_class
!module VerticalGrid_class8
!
!AUTHOR
!     J.W. Blezius MAY 2002 helper on top of the Interp1D library
!
!REVISION
! v1_0    Blezius J.W.          - initial version
! v1_4    Blezius J.W. AUG 2009 - split this file off of VerticalGrid.cdk90
!    ?    Blezius J.W. FEB 2010 - support UNnormalized hybrid grid
!                               - (due to hyb_to_pres) no longer require hybrid
!                                 ceiling to be the first element
!                               - inform the user only once of converting to ln P
!         Blezius J.W. DEC 2010 - add support for the staggered grid type
!
!OBJECT
!        A vertical grid is defined by the specific set of vertical levels in the
!        grid, along with an indication of the representation that is used for
!        the vertical levels, as well as all the parameters, except for surface
!        pressure, that are necessary to convert from that representation to a
!        representation by pressure.
!
!        Naturally, there is a constructor to define the grid and a destructor to
!        release memory that is associated with the grid.  Together, these are
!        the VerticalGrid_class that is defined in this module.
!       
!
!NOTES
!        Throughout, the object of the class on which the functions are to
!        operate is passed to each function as its first argument.
!
!        Ideally, the class member that defines what kind of vertical
!        representation is used would not be necessary.  Instead, each kind of
!        representation would be contained in a different sub-class of the
!        VerticalGrid_class.  Because fortran 90 does not explicitly support
!        inheritance, the older methods used here are easier.
!
!        The constructor and destructor do not deallocate the class object itself
!        because it is not necessarily on the heap.
!
!!
  use VerticalInterpolationConstants
  use vGrid_Descriptors
  implicit none
  public
  save

  real, parameter :: r_MBAR_PER_PASCAL = 0.01
  real, parameter :: r_LOG_MBAR_PER_PASCAL = log(0.01)

  type T_VerticalGrid
    ! information capable of specifying particular grid types is placed in
    !  variables here:
    integer N_numVLevels                ! number of vertical points in this grid

                                        ! The ip1's of the field levels that are
                                        ! present in the associated field
    integer, pointer, dimension(:) :: N_ip1_p
                                        ! The vgd that describes this grid
    type(vgrid_descriptor), pointer::O_vGridDesc_p
  end type T_VerticalGrid

  interface assignment(=)
    module procedure M_AssignVerticalGrid
  end interface

  interface operator(/=)
    module procedure M_NotEqualVerticalGrid
  end interface

  interface N_Viqkdef
    module procedure N_Viqkdef_ip1List
    module procedure N_Viqkdef_ip1Type
  end interface



contains

!!!func M_NotEqualVerticalGrid - non-equality comparison operator
  logical function M_NotEqualVerticalGrid(o_gridA, o_gridB)
!
!AUTHOR
!     J.W. Blezius OCT 2002
!
!REVISION
! v1_0    Blezius J.W.          - initial version
!
!OBJECT
!        To compare (that means a deep comparison) the value of one vertical
!        grid object to another.
!
!ARGUMENTS
    type (T_VerticalGrid), intent(in) :: o_gridA, &
                                         o_gridB
!
!NOTES
!
!!

  integer :: k                          ! index of the vertical levels


  M_NotEqualVerticalGrid = .false.      ! assume equal until proven otherwise

  if(o_gridA%N_numVLevels /= o_gridB%N_numVLevels) then
    M_NotEqualVerticalGrid = .true.
  else if(.not. (o_gridA%O_vGridDesc_p == o_gridB%O_vGridDesc_p)) then
      M_NotEqualVerticalGrid = .true.
  else
    do k=1, o_gridA%N_numVLevels
      if(o_gridA%N_ip1_p(k) /= o_gridB%N_ip1_p(k)) then
        M_NotEqualVerticalGrid = .true.
        exit                            ! no need to check any further
      end if
    end do
  end if

  end function M_NotEqualVerticalGrid



!!!s/r M_AssignVerticalGrid - assigment operator
  subroutine M_AssignVerticalGrid(o_gridOut, o_gridIn)
!
!AUTHOR
!     J.W. Blezius SEPT 2002
!
!REVISION
! v1_0    Blezius J.W.          - initial version
!
!OBJECT
!        To assign (that means a deep copy) the value of one vertical grid
!        object to another.
!
!ARGUMENTS
    type (T_VerticalGrid), intent(out) :: o_gridOut
    type (T_VerticalGrid), intent(in)  :: o_gridIn
!
!NOTES
!        This assumes that the destination vLevel array has been allocated, and
!        that the two vLevels have the same dimensions.
!
!!
    external flush
    integer :: n_error

    o_gridOut%N_numVLevels = o_gridIn%N_numVLevels
                                                      ! deep copy
    if(associated(o_gridIn%N_ip1_p))then
      if(associated(o_gridOut%N_ip1_p)) then
        if(size(o_gridOut%N_ip1_p) /= o_gridIn%N_numVLevels) then
          deallocate(o_gridOut%N_ip1_p)
          nullify(o_gridOut%N_ip1_p)
        end if
      end if

      if(.not. associated(o_gridOut%N_ip1_p)) then
          allocate(o_gridOut%N_ip1_p(o_gridIn%N_numVLevels), STAT=n_error)
          if(n_error /= 0) then
            write(6, *)'Error allocating ip1 in M_AssignVerticalGrid:  error=',&
                       n_error
            call flush(6)
            return
          endif
      end if

      o_gridOut%N_ip1_p = o_gridIn%N_ip1_p

    else ! .not. associated(o_gridIn%N_ip1_p)
      if(associated(o_gridOut%N_ip1_p)) then
        deallocate(o_gridOut%N_ip1_p)
        nullify(o_gridOut%N_ip1_p)
      end if
    end if

    o_gridOut%O_vGridDesc_p => o_gridIn%O_vGridDesc_p
  end subroutine M_AssignVerticalGrid



!!!func N_ConstructNull - constructor:  Put the object in a valid state
  integer function N_ConstructNull(this, n_numVLevelsIn)
                                        ! returns error indication:  0='no error'
!
!AUTHOR
!     J.W. Blezius DEC 2003
!
!REVISION
! v1_3    Blezius J.W. DEC 2003 - initial version
!
!OBJECT
!        The null VerticalGrid constructor.  This constructor simply puts the
!        object in a valid state, but containing no data.
!
!ARGUMENTS
    type(T_VerticalGrid), pointer, intent(inout) :: this
    integer, intent(in)::n_numVLevelsIn ! number of vertical levels in the object
!
!NOTES
!
!!
    external flush
    integer :: n_error

    N_ConstructNull = 0                 ! no error yet
    nullify(this%O_vGridDesc_p)

    if(n_numVLevelsIn == 0) then
        ! The size is not known yet; just nullify the pointer
        nullify(this%N_ip1_p)
    else
        allocate(this%N_ip1_p(n_numVLevelsIn), STAT=n_error)
        if(n_error /= 0) then
          write(6, *) 'Error allocating vLevel in N_ConstructNull:  error=', &
                      n_error
          call flush(6)
          N_ConstructNull = N_VI_VIERR_FAILED_ALLOCATION
          return
        endif ! n_error /= 0
        this%N_ip1_p = 0

    end if ! n_numVLevelsIn == 0
    
    ! Array of vertical levels was successfully allocated.
    this%N_numVLevels = n_numVLevelsIn

  end function N_ConstructNull



!!!func N_Viqkdef - OVERLOADED constructor:  Quick definition of the grid for
!                                            vertical integration
  integer function N_Viqkdef_ip1List(this, o_vGridDesc_p, n_ip1)
                                        ! returns error indication:  0='no error'
!
!AUTHOR
!     J.W. Blezius MAY 2002 helper on top of the Interp1D library
!
!REVISION
! v1_0    Blezius J.W.          - initial version
!
!OBJECT
!        The VerticalGrid constructor.  The attributes of the VerticalGrid_class
!        are initialized.  The ip1 values are obtained from the supplied list.
!
!NOTES
!        N_VIQKDEF IS OVERLOADED:  The ip1 list can be given either explicitly
!                                  or by naming the type of grid (momentum or
!                                  thermodynamic).  The two methods can be
!                                  distinguished by this ip1 parameter, and that
!                                  is the whole point of overloading the method.
!
!ARGUMENTS
    type(T_VerticalGrid), pointer, intent(inout) :: this
                                        ! The vgd that describes this grid
    type(vgrid_descriptor), pointer, intent(in)::o_vGridDesc_p
                                        ! The ip1's of field levels present
    integer, dimension(:), intent(in) :: n_ip1
!
!!
    external flush
    integer :: n_error, n_kind, n_version, n_numVLevels

    N_Viqkdef_ip1List = 0               ! no error yet
    this%O_vGridDesc_p => o_vGridDesc_p


    !
    ! DETERMINE THE IP1 VALUES
    !

    if (associated(this%N_ip1_p)) then
      deallocate(this%N_ip1_p)
    end if

    nullify(this%N_ip1_p)

    this%N_numVLevels = ubound(n_ip1,1)-lbound(n_ip1,1)+1

    allocate(this%N_ip1_p(this%N_numVLevels), STAT=n_error)
    if(n_error /= 0) then
      write(6, *) 'Error allocating this%N_ip1_p in N_Viqkdef: error=', n_error
      call flush(6)
      N_Viqkdef_ip1List = N_VI_VIERR_FAILED_ALLOCATION
      return
    endif

    ! ... IP1 VALUES GIVEN EXPLICITLY
    this%N_ip1_p = n_ip1

  end function N_Viqkdef_ip1List



!!!func N_Viqkdef - OVERLOADED constructor:  Quick definition of the grid for
!                                            vertical integration
  integer function N_Viqkdef_ip1Type(this, o_vGridDesc_p, s_ip1Type)
                                        ! returns error indication:  0='no error'
!
!AUTHOR
!     J.W. Blezius AUG 2015 overload the method.
!
!OBJECT
!        The VerticalGrid constructor.  The attributes of the VerticalGrid_class
!        are initialized.  The ip1 values are obtained from the vertical-grid
!        descriptor, given the type of grid (VIPT or VIPM).
!
!NOTES
!        For more information, see the header of the preceding method by the same
!        name.
!
!ARGUMENTS
    type(T_VerticalGrid), pointer, intent(inout) :: this
                                        ! The vgd that describes this grid
    type(vgrid_descriptor), pointer, intent(in)::o_vGridDesc_p
    character(len=4), intent(in) :: s_ip1Type ! VIPM or VIPT
!
!!
    external flush
    integer :: n_error, n_kind, n_version, n_numVLevels
    integer, pointer, dimension(:) :: n_ip1_p

    N_Viqkdef_ip1Type = 0               ! no error yet
    this%O_vGridDesc_p => o_vGridDesc_p

    !
    ! DETERMINE THE IP1 VALUES
    !

    if (associated(this%N_ip1_p)) then
      deallocate(this%N_ip1_p)
    end if

    nullify(this%N_ip1_p)
    nullify(n_ip1_p)

    ! ... IP1 VALUES FROM VGRID, GIVEN 'VIPT' / 'VIPM'
    ! Obtain a list of all (and then some) levels from vgrid
    n_error=vgd_get(this%O_vGridDesc_p, s_ip1Type, n_ip1_p)
    if(n_error /= VGD_OK)then
      write(6, *) 'Error from vgd_get in N_Viqkdef: error=', n_error
      call flush(6)
      N_Viqkdef_ip1Type = N_VI_VIERR_VGD_DESCRIPTOR_ERROR
    end if

    ! In order to adjust the number of levels, need the grid kind & version
    n_error=vgd_get(this%O_vGridDesc_p, 'KIND', n_kind)
    if(n_error /= VGD_OK)then
      write(6, *) 'Error getting n_kind in N_Viqkdef: error=', n_error
      call flush(6)
      N_Viqkdef_ip1Type = N_VI_VIERR_VGD_DESCRIPTOR_ERROR
    end if

    n_error=vgd_get(this%O_vGridDesc_p, 'VERS', n_version)
    if(n_error /= VGD_OK)then
      write(6, *) 'Error getting n_version in N_Viqkdef: error=', n_error
      call flush(6)
      N_Viqkdef_ip1Type = N_VI_VIERR_VGD_DESCRIPTOR_ERROR
    end if

    ! Omit the levels that would not be present in a field.
    ! Vgd might have (depending on the grid type) added hyb=1 (the last entry)
    ! and the 10m level (after hyb=1) to the list. Remove the 10m level.
    n_numVLevels = ubound(n_ip1_p,1)
    select case (n_kind*1000 + n_version)
    case (5005)
      n_numVLevels = n_numVLevels - 1

    case default
      ! Do not adjust the number of levels
    end select

    allocate(this%N_ip1_p(n_numVLevels), STAT=n_error)
    if(n_error /= 0) then
      write(6, *) 'Error allocating this%N_ip1_p in N_Viqkdef: error=', n_error
      call flush(6)
      N_Viqkdef_ip1Type = N_VI_VIERR_FAILED_ALLOCATION
      return
    endif

    this%N_ip1_p = n_ip1_p(:n_numVLevels)

    this%N_numVLevels = n_numVLevels

  end function N_Viqkdef_ip1Type



!!!func N_VertGridGetLnP - Create 'cube' of vertical levels in units of ln P
  integer function N_VertGridGetLnP(this, r_P, r_pSurf)
                                        ! returns error indication:  0='no error'
!
!AUTHOR
!     J.W. Blezius JULY 2002 helper on top of the Interp1D library
!
!REVISION
! v1_0    Blezius J.W.          - initial version
!
!OBJECT
!        The vertical grid is a 1-D object.  The product is taken with the
!        horizontal surface pressure, r_pSurf, to produce a cube of vertical
!        levels, in pressure units.
!
!        The exception is the 'generic' grid type.  In this case, the vertical
!        levels are simply multiplied horizontally, and no attempt is made to
!        obtain a pressure.
!
!NOTES
!
!ARGUMENTS

                                        ! parameter cannot be a pointer to a
                                        ! user type:  replace 'this' with 'that'
    type(T_VerticalGrid), pointer, intent(in) :: this

                                        ! vertical levels as pressure
    real(real48), dimension(:,:,:), intent(out) :: r_P

                                        ! surface pressure for each horiz point,
                                        ! in units of mb
    real(real48), dimension(:,:), intent(in) :: r_pSurf
!
!!
    external flush
    integer :: n_error

    real(single), dimension(:,:,:), pointer :: r_P_single_p
    logical, parameter :: l_IN_LOG = .true.
    logical :: l_firstTime=.true.


    nullify(r_P_single_p)
    N_VertGridGetLnP = 0                  ! no error yet
    

    if(l_firstTime .eqv. .true.) then
         l_firstTime=.false.
         write(6,*)' '
         write(6,*)'In ez_interpv, converting the vertical levels to ln P (1 mb ref level) before interpolating.'
         write(6,*)'(This message will not be repeated.)'
         write(6,*)' '
    endif

    !
    ! Create the 'cube' of source vertical levels
    !
                                        ! Obtain, the cube of P.
    allocate (r_P_single_p(ubound(r_pSurf,1),ubound(r_pSurf,2),this%N_numVLevels), STAT=n_error)
    if(n_error /= 0) then
      write(6, *)'Error allocating r_P_single_p in N_VertGridGetLnP:  error=',&
                 n_error
      call flush(6)
      return
    endif
    n_error = vgd_levels(this%O_vGridDesc_p, this%N_ip1_p(:this%N_numVLevels),&
                         r_P_single_p, &
                         real(r_pSurf, kind=4) / r_MBAR_PER_PASCAL, l_IN_LOG)
    if(n_error .ne. VGD_OK)then
      write(6,*)'ERROR in VerticalGrid_class%N_VertGridGetLnP, ', &
                'from vgd_levels:', n_error
      N_VertGridGetLnP = N_VI_VIERR_VGD_DESCRIPTOR_ERROR
    end if
    r_P = r_P_single_p + r_LOG_MBAR_PER_PASCAL

    deallocate(r_P_single_p)

  end function N_VertGridGetLnP



!!!s/r M_ReleaseVerticalGrid - VerticalGrid destructor
  subroutine M_ReleaseVerticalGrid(this)
!
!AUTHOR
!     J.W. Blezius MAY 2002 helper on top of the Interp1D library
!
!REVISION
! v1_0    Blezius J.W.          - initial version
!
!OBJECT
!        The memory associated with the attributes is released.
!
!ARGUMENTS
    implicit none
    type(T_VerticalGrid), pointer, intent(inout) :: this
!
!!
    external flush
    integer :: n_error


    if( associated(this%N_ip1_p) ) then
      deallocate (this%N_ip1_p, STAT=n_error)
      if(n_error /= 0) then
        write(6, *)'Error deallocating vLevel in M_ReleaseVerticalGrid:  ', &
                   'error=', n_error
        call flush(6)
      end if
    end if

    ! N.B.:  vgd_free does not deallocate data that were obtained with vgd_get
    n_error = vgd_free(this%O_vGridDesc_p)
    if(n_error /= VGD_OK) then
      write(6, *)'Error freeing vgrid descriptor object in ', &
                 'M_ReleaseVerticalGrid:  error from vgrid=', n_error
      call flush(6)
    end if

  end subroutine M_ReleaseVerticalGrid

!end module VerticalGrid_class
!end module VerticalGrid_class8
